import { Chatty } from '@looker/chatty';
import { EJSON } from 'bson';

// Given an object `Target`, find all property names of type `Type`
// Given an object `Target`, filter out all properties that aren't of type `Type`
function createElement(name) {
  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const element = document.createElement(name);

  for (const [name, value] of Object.entries(props)) {
    if (name === 'style') {
      Object.assign(element.style, props.style);
    } else {
      element.setAttribute(name, value);
    }
  }

  for (const child of Array.isArray(children) ? children : [children]) {
    element.append(child);
  }

  return element;
}

/**
 * Constructs the chart iframe URL from the baseUrl, chartId & tenantId
 */
const getChartUrl = options => {
  try {
    const url = new URL(options.baseUrl);
    url.pathname = [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', 'embed/charts'].join('');
    url.search = "id=".concat(options.chartId, "&sdk=1");
    url.search += options.refreshInterval ? "&autorefresh=".concat(options.refreshInterval) : '';
    url.search += options.filter ? "&filter=".concat(encodeURIComponent(EJSON.stringify(options.filter))) : '';
    url.search += options.theme ? "&theme=".concat(options.theme) : '';
    url.search += options.showAttribution === false ? "&attribution=".concat(options.showAttribution) : '';
    return url.toString();
  } catch (e) {
    throw new Error('Base URL must be a valid URL');
  }
};
/* Parses a CSS Measurement from an unknown value
     - if it's a string, we trust that it is well-formed
     - if it's a number, we assume the units are pixels
     - otherwise we return null
*/

const parseCSSMeasurement = value => {
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return "".concat(value, "px");
  return null;
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const getChartOptions = options => {
  if (typeof options !== 'object' || options === null) {
    throw new Error('Options argument must be an object');
  }

  const {
    baseUrl,
    chartId,
    filter,
    refreshInterval,
    width,
    height,
    theme,
    showAttribution,
    getUserToken
  } = options;

  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {
    throw new Error('Base URL must be a valid URL');
  }

  if (typeof chartId !== 'string' || chartId.length === 0) {
    throw new Error('Chart ID must be specified');
  }

  if (width !== undefined && !['number', 'string'].includes(typeof width)) {
    throw new Error('Width must be a string or number if specified');
  }

  if (height !== undefined && !['number', 'string'].includes(typeof height)) {
    throw new Error('Height must be a string or number if specified');
  }

  if (filter !== undefined && (!filter || typeof filter !== 'object')) {
    throw new Error('Filter must be an object if specified');
  }

  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {
    throw new Error('refreshInterval interval must be an object if specified');
  }

  if (theme !== undefined && typeof theme !== 'string') {
    throw new Error('Theme must be a string if specified');
  }

  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {
    throw new Error('Attribution must be a boolean value if specified');
  }

  if (getUserToken !== undefined && typeof getUserToken !== 'function') {
    throw new Error('getUserToken must be a function');
  }

  return {
    baseUrl,
    chartId,
    filter,
    refreshInterval,
    width,
    height,
    theme,
    showAttribution,
    getUserToken
  };
};

class Chart {
  constructor(options) {
    _defineProperty(this, "options", void 0);

    _defineProperty(this, "connection", void 0);

    _defineProperty(this, "iframe", void 0);

    this.options = getChartOptions(options);
  }

  _send(eventName) {
    if (this.connection) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }

      return this.connection.sendAndReceive(eventName, ...payload);
    }

    return Promise.reject('Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.');
  }

  setToken(token) {
    return this._send('set', 'token', token);
  }

  async retrieveAndSetToken() {
    if (this.options.getUserToken) {
      const token = await this.options.getUserToken();
      this.setToken(token);
    }
  }

  async refresh() {
    return await this._send('refresh');
  }

  async getRefreshInterval() {
    const [result] = await this._send('get', 'autorefresh');
    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');
  }

  async setRefreshInterval(value) {
    if (typeof value !== 'number') {
      return Promise.reject('refreshInterval property value should be a number');
    }

    await this._send('set', 'autorefresh', value);
    return;
  }

  async getFilter() {
    const [result] = await this._send('get', 'filter');
    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');
  }

  async setFilter(value) {
    if (typeof value !== 'object' || value === null || Array.isArray(value)) {
      return Promise.reject('filter property value should be an object');
    }

    await this._send('set', 'filter', EJSON.stringify(value));
    return;
  }

  async setTheme(value) {
    if (typeof value !== 'string') {
      return Promise.reject('theme property value should be a string');
    }

    await this._send('set', 'theme', value);
    return;
  }

  async getTheme() {
    const [result] = await this._send('get', 'theme');
    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');
  }

  render(container) {
    if (this.iframe) {
      throw new Error('A chart can only be rendered into a container once');
    }

    if (!(container instanceof HTMLElement)) {
      throw new Error('Target container must be a HTML element');
    } // Remove any existing nodes in our target container


    while (container.firstChild) container.removeChild(container.firstChild);

    const chartUrl = getChartUrl(this.options); // Create styled container

    const embedRoot = createElement('div', {
      style: {
        position: 'relative',
        overflow: 'hidden',
        width: parseCSSMeasurement(this.options.width) || '100%',
        height: parseCSSMeasurement(this.options.height) || '100%'
      }
    }); // Create iframe

    const host = Chatty.createHost(chartUrl).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').appendTo(embedRoot).on('refreshToken', () => this.retrieveAndSetToken()).build(); // Customise IFrame styles

    Object.assign(host.iframe.style, {
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      border: 0
    });
    container.appendChild(embedRoot);
    this.iframe = host.iframe;
    return host.connect().then(connection => {
      this.connection = connection;
      return this.retrieveAndSetToken();
    });
  }

}

class EmbedSDK {
  constructor(options) {
    _defineProperty(this, "defaultOptions", void 0);

    this.defaultOptions = options;
  }

  createChart(options) {
    return new Chart(_objectSpread({}, this.defaultOptions, {}, options));
  }

}

export default EmbedSDK;
