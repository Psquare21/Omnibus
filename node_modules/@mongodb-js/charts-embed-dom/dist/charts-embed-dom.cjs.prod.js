"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var chatty = require("@looker/chatty"), bson = require("bson");

function createElement(name) {
  let props = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, children = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
  const element = document.createElement(name);
  for (const [name, value] of Object.entries(props)) "style" === name ? Object.assign(element.style, props.style) : element.setAttribute(name, value);
  for (const child of Array.isArray(children) ? children : [ children ]) element.append(child);
  return element;
}

const getChartUrl = options => {
  try {
    const url = new URL(options.baseUrl);
    return url.pathname = [ url.pathname, "/" === url.pathname.slice(-1) ? "" : "/", "embed/charts" ].join(""), 
    url.search = "id=".concat(options.chartId, "&sdk=1"), url.search += options.refreshInterval ? "&autorefresh=".concat(options.refreshInterval) : "", 
    url.search += options.filter ? "&filter=".concat(encodeURIComponent(bson.EJSON.stringify(options.filter))) : "", 
    url.search += options.theme ? "&theme=".concat(options.theme) : "", url.search += !1 === options.showAttribution ? "&attribution=".concat(options.showAttribution) : "", 
    url.toString();
  } catch (e) {
    throw new Error("Base URL must be a valid URL");
  }
}, parseCSSMeasurement = value => "string" == typeof value ? value : "number" == typeof value ? "".concat(value, "px") : null;

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

const getChartOptions = options => {
  if ("object" != typeof options || null === options) throw new Error("Options argument must be an object");
  const {baseUrl: baseUrl, chartId: chartId, filter: filter, refreshInterval: refreshInterval, width: width, height: height, theme: theme, showAttribution: showAttribution, getUserToken: getUserToken} = options;
  if ("string" != typeof baseUrl || 0 === baseUrl.length) throw new Error("Base URL must be a valid URL");
  if ("string" != typeof chartId || 0 === chartId.length) throw new Error("Chart ID must be specified");
  if (void 0 !== width && ![ "number", "string" ].includes(typeof width)) throw new Error("Width must be a string or number if specified");
  if (void 0 !== height && ![ "number", "string" ].includes(typeof height)) throw new Error("Height must be a string or number if specified");
  if (void 0 !== filter && (!filter || "object" != typeof filter)) throw new Error("Filter must be an object if specified");
  if (void 0 !== refreshInterval && "number" != typeof refreshInterval) throw new Error("refreshInterval interval must be an object if specified");
  if (void 0 !== theme && "string" != typeof theme) throw new Error("Theme must be a string if specified");
  if (void 0 !== showAttribution && "boolean" != typeof showAttribution) throw new Error("Attribution must be a boolean value if specified");
  if (void 0 !== getUserToken && "function" != typeof getUserToken) throw new Error("getUserToken must be a function");
  return {
    baseUrl: baseUrl,
    chartId: chartId,
    filter: filter,
    refreshInterval: refreshInterval,
    width: width,
    height: height,
    theme: theme,
    showAttribution: showAttribution,
    getUserToken: getUserToken
  };
};

class Chart {
  constructor(options) {
    _defineProperty(this, "options", void 0), _defineProperty(this, "connection", void 0), 
    _defineProperty(this, "iframe", void 0), this.options = getChartOptions(options);
  }
  _send(eventName) {
    if (this.connection) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) payload[_key - 1] = arguments[_key];
      return this.connection.sendAndReceive(eventName, ...payload);
    }
    return Promise.reject("Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.");
  }
  setToken(token) {
    return this._send("set", "token", token);
  }
  async retrieveAndSetToken() {
    if (this.options.getUserToken) {
      const token = await this.options.getUserToken();
      this.setToken(token);
    }
  }
  async refresh() {
    return await this._send("refresh");
  }
  async getRefreshInterval() {
    const [result] = await this._send("get", "autorefresh");
    return "number" == typeof result ? result : Promise.reject("unexpected response received from iframe");
  }
  async setRefreshInterval(value) {
    if ("number" != typeof value) return Promise.reject("refreshInterval property value should be a number");
    await this._send("set", "autorefresh", value);
  }
  async getFilter() {
    const [result] = await this._send("get", "filter");
    return "object" == typeof result && null !== result ? result : Promise.reject("unexpected response received from iframe");
  }
  async setFilter(value) {
    if ("object" != typeof value || null === value || Array.isArray(value)) return Promise.reject("filter property value should be an object");
    await this._send("set", "filter", bson.EJSON.stringify(value));
  }
  async setTheme(value) {
    if ("string" != typeof value) return Promise.reject("theme property value should be a string");
    await this._send("set", "theme", value);
  }
  async getTheme() {
    const [result] = await this._send("get", "theme");
    return "string" == typeof result ? result : Promise.reject("unexpected response received from iframe");
  }
  render(container) {
    if (this.iframe) throw new Error("A chart can only be rendered into a container once");
    if (!(container instanceof HTMLElement)) throw new Error("Target container must be a HTML element");
    for (;container.firstChild; ) container.removeChild(container.firstChild);
    const chartUrl = getChartUrl(this.options), embedRoot = createElement("div", {
      style: {
        position: "relative",
        overflow: "hidden",
        width: parseCSSMeasurement(this.options.width) || "100%",
        height: parseCSSMeasurement(this.options.height) || "100%"
      }
    }), host = chatty.Chatty.createHost(chartUrl).withSandboxAttribute("allow-scripts").withSandboxAttribute("allow-same-origin").appendTo(embedRoot).on("refreshToken", () => this.retrieveAndSetToken()).build();
    return Object.assign(host.iframe.style, {
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      border: 0
    }), container.appendChild(embedRoot), this.iframe = host.iframe, host.connect().then(connection => (this.connection = connection, 
    this.retrieveAndSetToken()));
  }
}

class EmbedSDK {
  constructor(options) {
    _defineProperty(this, "defaultOptions", void 0), this.defaultOptions = options;
  }
  createChart(options) {
    return new Chart(_objectSpread({}, this.defaultOptions, {}, options));
  }
}

exports.default = EmbedSDK;
